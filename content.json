{"meta":{"title":"Taylor 的博客,biu biu biu","subtitle":null,"description":null,"author":"Taylor","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"Valid Parentheses","slug":"Valid-Parentheses","date":"2019-07-28T08:30:49.758Z","updated":"2019-07-28T08:30:49.876Z","comments":true,"path":"2019/07/28/Valid-Parentheses/","link":"","permalink":"http://yoursite.com/2019/07/28/Valid-Parentheses/","excerpt":"有效的括号正在加载今日诗词…. 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"有效的括号正在加载今日诗词…. 给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。 有效字符串需满足： 左括号必须用相同类型的右括号闭合。左括号必须以正确的顺序闭合。注意空字符串可被认为是有效字符串。 示例 1: 输入: “()”输出: true示例 2: 输入: “()[]{}”输出: true示例 3: 输入: “(]”输出: false示例 4: 输入: “([)]”输出: false示例 5: 输入: “{[]}”输出: true 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include&lt;stdio.h&gt;#include &lt;stdlib.h&gt;//定义栈//入栈字符串（若字符串为奇数，可直接判定为无效）//当遇到匹配的时候出栈栈顶元素//若全部元素进栈后，栈为空，则为有效//否则无效typedef struct Node &#123; char var; struct Node* next;&#125;LinkNode,* PtrNode;typedef struct LinkStack &#123; PtrNode top; int count;&#125;Stack;int initStack(Stack* stack) &#123; stack-&gt;top = (PtrNode)malloc(sizeof(LinkNode)); stack-&gt;top = NULL; stack-&gt;count = 0; return 0;&#125;int isEmpty(Stack stack)&#123; if (stack.count==0) &#123; return 0; //空栈返回 0 ，非空返回1 &#125; return 1;&#125;int push(Stack* stack,char c)&#123; PtrNode insertNode = (PtrNode)malloc(sizeof(LinkNode)); stack-&gt;count++; insertNode-&gt;var = c; insertNode-&gt;next = stack-&gt;top; stack-&gt;top = insertNode; return 1;&#125;int pop(Stack* stack) &#123; if (!isEmpty(*stack)) return 0; //若为空栈，不能退栈 //空栈返回 0 ，非空返回1 stack-&gt;count--; PtrNode temp = (PtrNode)malloc(sizeof(LinkNode)); temp = stack-&gt;top; stack-&gt;top = stack-&gt;top-&gt;next; free(temp); return 0;&#125;char getTop(Stack stack) &#123; if (!isEmpty(stack))//空栈返回 0 ，非空返回1 &#123; //printf(\"空栈\"); return 0; &#125; return stack.top-&gt;var;&#125;int isValid(char* s) &#123; //定义栈 Stack stack; initStack(&amp;stack); int length = strlen(s); if (length % 2) return 0; //如果字符长度为奇数，那么直接判定为 无效的 for (int i = 0; i &lt; length; i++) &#123; char t = getTop(stack); //获取栈顶元素 //与准备进栈元素匹配，如果匹配，则跳过当前入栈元素，并出栈栈顶元素，否则进栈 if (((t == '(' )&amp;&amp;( s[i] == ')')) || ((t == '[') &amp;&amp;( s[i] == ']')) ||( (t == '&#123;' )&amp;&amp;( s[i] == '&#125;'))) &#123; pop(&amp;stack); &#125;else&#123; push(&amp;stack, s[i]); &#125; &#125; //判断栈是否为空 return !isEmpty(stack);//空栈返回 0 ，非空返回1 ，返回1 为有效&#125;int main() &#123; char* str = \"()\"; if (isValid(str)==1) &#123; printf(\"有效\"); &#125; // 空栈返回 0 -》有效 ，非空返回1-》无效 else &#123;printf(\"无效\");&#125; return 0;&#125; 解题思路：又是在学数据结构的时候遇到过的内容，当时遇到的是关于波兰式，将逆波兰式，波兰式，中缀式表达式转化的问题，当时提出的解决方法就是用栈来解决的。于是思考，有效的一个符号序列是什么特点？没错，就是一一对应，想想连连看，找到对应的，消去，剩下的是空集，不就说明是有效的吗？那么，怎么实现—栈。将这个有序符号集入栈，将入栈的元素与栈顶元素相匹配，如果匹配，就将这一对“消去”（出栈栈顶元素和跳过当前元素，不将当前元素入栈），若不匹配，那么将当前元素入栈，重复执行上述步骤，直到所有元素都经历上述步骤。最后看结果，若最后栈为空栈，则说明全部被消掉了，即为有效，否则为无效。 在做这题的时候，考虑了用顺序栈做，但是想了想，题目中未提及这个序列的大小，所以选择了链栈做。当然使用顺序栈做占用空间小。","categories":[],"tags":[]},{"title":"merge Two Lists","slug":"mergeTwoLists","date":"2019-07-27T14:03:22.738Z","updated":"2019-07-28T08:03:12.014Z","comments":true,"path":"2019/07/27/mergeTwoLists/","link":"","permalink":"http://yoursite.com/2019/07/27/mergeTwoLists/","excerpt":"合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists","text":"合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 双指针（迭代）一个指针指向链表A,一个链表指向链表B，还有一个 目标链表 ，用于存储合并后的链表。 将节点A的值和节点B的相比较，小的值对应的节点链接到目标链表中，否则将另一条链表的节点链接到目标链表中。 将当前节点向后移动一位，来比较下一位的值。 循环处理，直到某一条链表到达尾部，则将另一条剩余位处理的节点链接到目标链表上。 C 语言代码123456789101112131415161718192021222324252627282930313233struct ListNode* mergeTwoLists(NodePtr ptrA, NodePtr ptrB) &#123; NodePtr listANS = (NodePtr)malloc(sizeof(LinkNode)); NodePtr head =(NodePtr)malloc(sizeof(LinkNode)); head = listANS; listANS-&gt;next = NULL; while (ptrA &amp;&amp; ptrB)// ptrA和ptrB都不为空的时候执行循环 &#123; if (ptrA-&gt;val &lt; ptrB-&gt;val) //如果A的值小于B的值，那么将A的值赋给新表 &#123; listANS-&gt;next = ptrA; ptrA = ptrA-&gt;next; //listANS = listANS-&gt;next; &#125; else &#123; listANS-&gt;next = ptrB; ptrB = ptrB-&gt;next; //listANS = listANS-&gt;next; //两个选项都有执行，放到外面 &#125; listANS = listANS-&gt;next; &#125; //循环终止，判断谁到尾部，并将另一条链表接到list3中去 //a?b:c listANS-&gt;next = !ptrA ? ptrB : ptrA ; //用三目运算代替if语句 /*if (!ptrA) &#123; listANS-&gt;next = ptrB; &#125; else &#123; listANS-&gt;next = ptrA; &#125;*/ return head-&gt;next;&#125; JAVA 语言代码123456789101112131415161718192021222324public static ListNode mergeTwoLists(ListNode list1Curr, ListNode list2Curr) &#123; ListNode list = new ListNode(0) ; ListNode list3 = list; list = list3; list3.next = null; while (list1Curr != null &amp;&amp; list2Curr != null)&#123; //当其中任意一个链表到尾部时，停止 if (list1Curr.val &lt; list2Curr.val)&#123; //如果list1 的值小，那么将list1 的值赋给list3，此时；list 1 curr 向后移动一位 list3.next = list1Curr; list1Curr = list1Curr.next; &#125;else&#123; //否则将list2 的值赋给list3，此时 list2curr 向后移动一位 list3.next = list2Curr; list1Curr = list2Curr.next; &#125; list3 = list3.next ; &#125; //循环终止，判断谁到尾部，并将另一条链表接到list3中去 if (list1Curr == null )&#123; list3.next = list2Curr; &#125;else &#123; list3.next = list1Curr; &#125; return list.next;&#125;//不知道为什么我这个代码提交上去总是提示超时，看了下官方答案也有这个方法。 递归学数据结构的时候，书上的代码就是上一种求解方法，所以首先想到的就是迭代的方法。 官方的递归解答： 想法 我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）： 也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。 算法 我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。 作者：LeetCode链接：https://leetcode-cn.com/problems/two-sum/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 JAVA 代码12345678910111213141516public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 总结：+++ 刚开始写的总是得不到正确的答案，原因在于返回值指向的并不是目标链表的头节点。抓住一点，指针，就是地址。指针域（假设讨论的值有一个next指针域）存储的就是指针，也就是下一个节点的地址。 遇到迭代的问题可以尝试用递归的思想思考，虽然递归会消耗大量的内存，但代码十分简练。","categories":[],"tags":[]},{"title":"two sum","slug":"twosum","date":"2019-07-25T09:23:47.903Z","updated":"2019-07-28T08:03:51.766Z","comments":true,"path":"2019/07/25/twosum/","link":"","permalink":"http://yoursite.com/2019/07/25/twosum/","excerpt":"两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"两数之和给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 暴力破解循环嵌套，将数组的数值相加，直到找到指定的target 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = &#123;0,0&#125;; for (int i = 0 ; i &lt;nums.length-1; i++)&#123; for(int j = i+1;j&lt;nums.length;j++)&#123; if (nums[i]+nums[j]==target)&#123; result[0] = i ; result[1] = j ; &#125; &#125; &#125; return result; &#125;&#125; 29 / 29 个通过测试用例 状态：通过 执行用时：66 ms 两遍哈希表123456789101112public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int j = 0; j &lt; nums.length; j++) &#123; int complement = target - nums[j]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != j) &#123; return new int[]&#123;j,map.get(complement)&#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 创建一个哈希表 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); 将数组1的下标作为value，数组的值作为key ,这样就创建了数组值和标的映射。 key value 2 1 7 2 11 3 15 4 只需执行一遍循环。首先数组循环 nums[i]*，然后求得 *target-nums[i] ，使用 if语句判断符合的条件，寻找哈希表中的目标值（target-nums[i]）。map.containKey(target-nums[i])&amp;&amp;map.get(complement) != i 符合条件的则返回value和当前的下标 i。 其实哈希表的 map.containKey也是使用了循环的，也是使用了嵌套循环,所以复杂度和暴力破解法差不多 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 一遍哈希表在插入哈希表的时候就开始寻找目标值（target-nums[i]） 123456789101112 public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 总结创建哈希表看起来是简单许多，但是花费了更多的空间，并且哈希表的containKey方法 还有一层循环，总的来说还是暴力破解来的简单点。","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]},{"title":"Roman to Integer","slug":"Roman-to-Integer","date":"2019-07-21T05:33:57.706Z","updated":"2019-07-28T07:58:47.490Z","comments":true,"path":"2019/07/21/Roman-to-Integer/","link":"","permalink":"http://yoursite.com/2019/07/21/Roman-to-Integer/","excerpt":"将罗马数字转位整数题目描述：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000","text":"将罗马数字转位整数题目描述：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III”输出: 3示例 2: 输入: “IV”输出: 4示例 3: 输入: “IX”输出: 9示例 4: 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public static void main(String[] args) &#123; int ans = romanToInt(\"MDCXCV\"); System.out.println(ans); &#125; public static int romanToInt(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int length = s.length(); int front = 0 ,later = 0 ,curr = 0 ; for (int i =0 ; i&lt;length ; i++)&#123; if (i &lt; length-1 )&#123; front = map.get(s.charAt(i)); later = map.get(s.charAt(i + 1)); &#125;else &#123; front = front = map.get(s.charAt(i)); later = 0 ; &#125; if (front&lt;later)&#123; curr = curr + later - front ; i = i + 1; &#125;else &#123; curr = curr + front; &#125; &#125; return curr; &#125;&#125; 执行结果：通过显示详情执行用时 :32 ms, 在所有 Java 提交中击败了36.95%的用户内存消耗 :40.4 MB, 在所有 Java 提交中击败了72.17%的用户 解题思路： 创建一个哈希表，将罗马数字与值相对应。 12345map.put('V',5);map.put('X',10);map.put('L',50);map.put('C',100);map.put('D',500) 求出罗马数字的长度，用于控制循环 一般情况，直接向后加 循环遍历“每一位”字母，因为 “通常情况下，罗马数字中小的数字在大的数字的右边” ，所以在这种情况下可以直接将值相加。 ​ 例如： 123LVIII输出: 58解释: L = 50, V= 5, III = 3. 比较前一位和后一位的大小 但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 那么需要有两个标记来记录前一位和后一位的值，判断前一位和后一位的大小。如果前一位更小，那么，用后一位减去前一位得到当前两位的值。即，该两位罗马字母代表一个值。因此，在循环时需要跳过一位（后一位）罗马字母，（变量自增）。 当循环变量增长到 s.length()-1时，front = map.get(s.charAt(i));和later = map.get(s.charAt(i + 1));当中的 later会数组越界，那么这时候需要在前面添加判断语句，并执行赋值，目的是将罗马数字的最后一位加上去","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"}]}]}