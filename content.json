{"meta":{"title":"Taylor 的博客,biu biu biu","subtitle":null,"description":null,"author":"Taylor","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"","slug":"mergeTwoLists","date":"2019-07-27T14:03:22.738Z","updated":"2019-07-27T15:32:13.570Z","comments":true,"path":"2019/07/27/mergeTwoLists/","link":"","permalink":"http://yoursite.com/2019/07/27/mergeTwoLists/","excerpt":"title: 合并两个有序链表 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists","text":"title: 合并两个有序链表 合并两个有序链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例： 输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists 双指针（迭代）一个指针指向链表A,一个链表指向链表B，还有一个 目标链表 ，用于存储合并后的链表。 将节点A的值和节点B的相比较，小的值对应的节点链接到目标链表中，否则将另一条链表的节点链接到目标链表中。 将当前节点向后移动一位，来比较下一位的值。 循环处理，直到某一条链表到达尾部，则将另一条剩余位处理的节点链接到目标链表上。 C 语言代码123456789101112131415161718192021222324252627282930313233struct ListNode* mergeTwoLists(NodePtr ptrA, NodePtr ptrB) &#123; NodePtr listANS = (NodePtr)malloc(sizeof(LinkNode)); NodePtr head =(NodePtr)malloc(sizeof(LinkNode)); head = listANS; listANS-&gt;next = NULL; while (ptrA &amp;&amp; ptrB)// ptrA和ptrB都不为空的时候执行循环 &#123; if (ptrA-&gt;val &lt; ptrB-&gt;val) //如果A的值小于B的值，那么将A的值赋给新表 &#123; listANS-&gt;next = ptrA; ptrA = ptrA-&gt;next; //listANS = listANS-&gt;next; &#125; else &#123; listANS-&gt;next = ptrB; ptrB = ptrB-&gt;next; //listANS = listANS-&gt;next; //两个选项都有执行，放到外面 &#125; listANS = listANS-&gt;next; &#125; //循环终止，判断谁到尾部，并将另一条链表接到list3中去 //a?b:c listANS-&gt;next = !ptrA ? ptrB : ptrA ; //用三目运算代替if语句 /*if (!ptrA) &#123; listANS-&gt;next = ptrB; &#125; else &#123; listANS-&gt;next = ptrA; &#125;*/ return head-&gt;next;&#125; JAVA 语言代码123456789101112131415161718192021222324public static ListNode mergeTwoLists(ListNode list1Curr, ListNode list2Curr) &#123; ListNode list = new ListNode(0) ; ListNode list3 = list; list = list3; list3.next = null; while (list1Curr != null &amp;&amp; list2Curr != null)&#123; //当其中任意一个链表到尾部时，停止 if (list1Curr.val &lt; list2Curr.val)&#123; //如果list1 的值小，那么将list1 的值赋给list3，此时；list 1 curr 向后移动一位 list3.next = list1Curr; list1Curr = list1Curr.next; &#125;else&#123; //否则将list2 的值赋给list3，此时 list2curr 向后移动一位 list3.next = list2Curr; list1Curr = list2Curr.next; &#125; list3 = list3.next ; &#125; //循环终止，判断谁到尾部，并将另一条链表接到list3中去 if (list1Curr == null )&#123; list3.next = list2Curr; &#125;else &#123; list3.next = list1Curr; &#125; return list.next;&#125;//不知道为什么我这个代码提交上去总是提示超时，看了下官方答案也有这个方法。 递归学数据结构的时候，书上的代码就是上一种求解方法，所以首先想到的就是迭代的方法。 官方的递归解答： 想法 我们可以如下递归地定义在两个链表里的 merge 操作（忽略边界情况，比如空链表等）： 也就是说，两个链表头部较小的一个与剩下元素的 merge 操作结果合并。 算法 我们直接将以上递归过程建模，首先考虑边界情况。 特殊的，如果 l1 或者 l2 一开始就是 null ，那么没有任何操作需要合并，所以我们只需要返回非空链表。否则，我们要判断 l1 和 l2 哪一个的头元素更小，然后递归地决定下一个添加到结果里的值。如果两个链表都是空的，那么过程终止，所以递归过程最终一定会终止。 作者：LeetCode链接：https://leetcode-cn.com/problems/two-sum/solution/he-bing-liang-ge-you-xu-lian-biao-by-leetcode/来源：力扣（LeetCode）著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 JAVA 代码12345678910111213141516public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; else if (l2 == null) &#123; return l1; &#125; else if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 总结：+++ 刚开始写的总是得不到正确的答案，原因在于返回值指向的并不是目标链表的头节点。抓住一点，指针，就是地址。指针域（假设讨论的值有一个next指针域）存储的就是指针，也就是下一个节点的地址。 遇到迭代的问题可以尝试用递归的思想思考，虽然递归会消耗大量的内存，但代码十分简练。","categories":[],"tags":[]},{"title":"两数之和","slug":"twosum","date":"2019-07-25T09:23:47.903Z","updated":"2019-07-25T09:23:48.027Z","comments":true,"path":"2019/07/25/twosum/","link":"","permalink":"http://yoursite.com/2019/07/25/twosum/","excerpt":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 暴力破解循环嵌套，将数组的数值相加，直到找到指定的target 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = &#123;0,0&#125;; for (int i = 0 ; i &lt;nums.length-1; i++)&#123; for(int j = i+1;j&lt;nums.length;j++)&#123; if (nums[i]+nums[j]==target)&#123; result[0] = i ; result[1] = j ; &#125; &#125; &#125; return result; &#125;&#125; 29 / 29 个通过测试用例 状态：通过 执行用时：66 ms 两遍哈希表123456789101112public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int j = 0; j &lt; nums.length; j++) &#123; int complement = target - nums[j]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != j) &#123; return new int[]&#123;j,map.get(complement)&#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 创建一个哈希表 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); 将数组1的下标作为value，数组的值作为key ,这样就创建了数组值和标的映射。 key value 2 1 7 2 11 3 15 4 只需执行一遍循环。首先数组循环 nums[i]*，然后求得 *target-nums[i] ，使用 if语句判断符合的条件，寻找哈希表中的目标值（target-nums[i]）。map.containKey(target-nums[i])&amp;&amp;map.get(complement) != i 符合条件的则返回value和当前的下标 i。 其实哈希表的 map.containKey也是使用了循环的，也是使用了嵌套循环,所以复杂度和暴力破解法差不多 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 一遍哈希表在插入哈希表的时候就开始寻找目标值（target-nums[i]） 123456789101112 public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 总结创建哈希表看起来是简单许多，但是花费了更多的空间，并且哈希表的containKey方法 还有一层循环，总的来说还是暴力破解来的简单点。","categories":[],"tags":[]},{"title":"Roman to Integer","slug":"Roman-to-Integer","date":"2019-07-21T05:33:57.706Z","updated":"2019-07-24T11:48:29.956Z","comments":true,"path":"2019/07/21/Roman-to-Integer/","link":"","permalink":"http://yoursite.com/2019/07/21/Roman-to-Integer/","excerpt":"将罗马数字转位整数题目描述：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000","text":"将罗马数字转位整数题目描述：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III”输出: 3示例 2: 输入: “IV”输出: 4示例 3: 输入: “IX”输出: 9示例 4: 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public static void main(String[] args) &#123; int ans = romanToInt(\"MDCXCV\"); System.out.println(ans); &#125; public static int romanToInt(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int length = s.length(); int front = 0 ,later = 0 ,curr = 0 ; for (int i =0 ; i&lt;length ; i++)&#123; if (i &lt; length-1 )&#123; front = map.get(s.charAt(i)); later = map.get(s.charAt(i + 1)); &#125;else &#123; front = front = map.get(s.charAt(i)); later = 0 ; &#125; if (front&lt;later)&#123; curr = curr + later - front ; i = i + 1; &#125;else &#123; curr = curr + front; &#125; &#125; return curr; &#125;&#125; 执行结果：通过显示详情执行用时 :32 ms, 在所有 Java 提交中击败了36.95%的用户内存消耗 :40.4 MB, 在所有 Java 提交中击败了72.17%的用户 解题思路： 创建一个哈希表，将罗马数字与值相对应。 12345map.put('V',5);map.put('X',10);map.put('L',50);map.put('C',100);map.put('D',500) 求出罗马数字的长度，用于控制循环 一般情况，直接向后加 循环遍历“每一位”字母，因为 “通常情况下，罗马数字中小的数字在大的数字的右边” ，所以在这种情况下可以直接将值相加。 ​ 例如： 123LVIII输出: 58解释: L = 50, V= 5, III = 3. 比较前一位和后一位的大小 但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 那么需要有两个标记来记录前一位和后一位的值，判断前一位和后一位的大小。如果前一位更小，那么，用后一位减去前一位得到当前两位的值。即，该两位罗马字母代表一个值。因此，在循环时需要跳过一位（后一位）罗马字母，（变量自增）。 当循环变量增长到 s.length()-1时，front = map.get(s.charAt(i));和later = map.get(s.charAt(i + 1));当中的 later会数组越界，那么这时候需要在前面添加判断语句，并执行赋值，目的是将罗马数字的最后一位加上去","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-21T02:36:01.834Z","updated":"2019-07-21T02:36:01.834Z","comments":true,"path":"2019/07/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}