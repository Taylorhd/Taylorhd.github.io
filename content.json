{"meta":{"title":"Taylor 的博客,biu biu biu","subtitle":null,"description":null,"author":"Taylor","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"两数之和","slug":"twosum","date":"2019-07-25T09:23:47.903Z","updated":"2019-07-25T09:23:48.027Z","comments":true,"path":"2019/07/25/twosum/","link":"","permalink":"http://yoursite.com/2019/07/25/twosum/","excerpt":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。","text":"给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。 你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例: 给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/two-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 暴力破解循环嵌套，将数组的数值相加，直到找到指定的target 1234567891011121314class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; int[] result = &#123;0,0&#125;; for (int i = 0 ; i &lt;nums.length-1; i++)&#123; for(int j = i+1;j&lt;nums.length;j++)&#123; if (nums[i]+nums[j]==target)&#123; result[0] = i ; result[1] = j ; &#125; &#125; &#125; return result; &#125;&#125; 29 / 29 个通过测试用例 状态：通过 执行用时：66 ms 两遍哈希表123456789101112public int[] twoSum(int[] nums, int target) &#123; HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; map.put(nums[i], i); &#125; for (int j = 0; j &lt; nums.length; j++) &#123; int complement = target - nums[j]; if (map.containsKey(complement) &amp;&amp; map.get(complement) != j) &#123; return new int[]&#123;j,map.get(complement)&#125;; &#125; &#125; throw new IllegalArgumentException(\"No two sum solution\");&#125; 创建一个哈希表 HashMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); 将数组1的下标作为value，数组的值作为key ,这样就创建了数组值和标的映射。 key value 2 1 7 2 11 3 15 4 只需执行一遍循环。首先数组循环 nums[i]*，然后求得 *target-nums[i] ，使用 if语句判断符合的条件，寻找哈希表中的目标值（target-nums[i]）。map.containKey(target-nums[i])&amp;&amp;map.get(complement) != i 符合条件的则返回value和当前的下标 i。 其实哈希表的 map.containKey也是使用了循环的，也是使用了嵌套循环,所以复杂度和暴力破解法差不多 12345678910111213141516171819final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125; 一遍哈希表在插入哈希表的时候就开始寻找目标值（target-nums[i]） 123456789101112 public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; i++) &#123; int complement = target - nums[i]; if (map.containsKey(complement)) &#123; return new int[] &#123; map.get(complement), i &#125;; &#125; map.put(nums[i], i); &#125; throw new IllegalArgumentException(\"No two sum solution\"); &#125;&#125; 总结创建哈希表看起来是简单许多，但是花费了更多的空间，并且哈希表的containKey方法 还有一层循环，总的来说还是暴力破解来的简单点。","categories":[],"tags":[]},{"title":"Roman to Integer","slug":"Roman-to-Integer","date":"2019-07-21T05:33:57.706Z","updated":"2019-07-24T11:48:29.956Z","comments":true,"path":"2019/07/21/Roman-to-Integer/","link":"","permalink":"http://yoursite.com/2019/07/21/Roman-to-Integer/","excerpt":"将罗马数字转位整数题目描述：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000","text":"将罗马数字转位整数题目描述：罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 字符 数值I 1V 5X 10L 50C 100D 500M 1000 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + II 。 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 示例 1: 输入: “III”输出: 3示例 2: 输入: “IV”输出: 4示例 3: 输入: “IX”输出: 9示例 4: 输入: “LVIII”输出: 58解释: L = 50, V= 5, III = 3.示例 5: 输入: “MCMXCIV”输出: 1994解释: M = 1000, CM = 900, XC = 90, IV = 4. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/roman-to-integer著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011121314151617181920212223242526272829303132333435public class Solution &#123; public static void main(String[] args) &#123; int ans = romanToInt(\"MDCXCV\"); System.out.println(ans); &#125; public static int romanToInt(String s) &#123; HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;(); map.put('I',1); map.put('V',5); map.put('X',10); map.put('L',50); map.put('C',100); map.put('D',500); map.put('M',1000); int length = s.length(); int front = 0 ,later = 0 ,curr = 0 ; for (int i =0 ; i&lt;length ; i++)&#123; if (i &lt; length-1 )&#123; front = map.get(s.charAt(i)); later = map.get(s.charAt(i + 1)); &#125;else &#123; front = front = map.get(s.charAt(i)); later = 0 ; &#125; if (front&lt;later)&#123; curr = curr + later - front ; i = i + 1; &#125;else &#123; curr = curr + front; &#125; &#125; return curr; &#125;&#125; 执行结果：通过显示详情执行用时 :32 ms, 在所有 Java 提交中击败了36.95%的用户内存消耗 :40.4 MB, 在所有 Java 提交中击败了72.17%的用户 解题思路： 创建一个哈希表，将罗马数字与值相对应。 12345map.put('V',5);map.put('X',10);map.put('L',50);map.put('C',100);map.put('D',500) 求出罗马数字的长度，用于控制循环 一般情况，直接向后加 循环遍历“每一位”字母，因为 “通常情况下，罗马数字中小的数字在大的数字的右边” ，所以在这种情况下可以直接将值相加。 ​ 例如： 123LVIII输出: 58解释: L = 50, V= 5, III = 3. 比较前一位和后一位的大小 但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 那么需要有两个标记来记录前一位和后一位的值，判断前一位和后一位的大小。如果前一位更小，那么，用后一位减去前一位得到当前两位的值。即，该两位罗马字母代表一个值。因此，在循环时需要跳过一位（后一位）罗马字母，（变量自增）。 当循环变量增长到 s.length()-1时，front = map.get(s.charAt(i));和later = map.get(s.charAt(i + 1));当中的 later会数组越界，那么这时候需要在前面添加判断语句，并执行赋值，目的是将罗马数字的最后一位加上去","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2019-07-21T02:36:01.834Z","updated":"2019-07-21T02:36:01.834Z","comments":true,"path":"2019/07/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/07/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}